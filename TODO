TODO

* Interface
  - D+ (sugared, sets all the syntax parameters, filters the closure vars out)
  - D* (plain)
  - define/backprop
  - grad
  - explicit closure vars can be passed to D+/D* by the user
  - make (D+ f) work as well as (D+ (lambda (x) (f x))) [should just look up the backpropagator for primitives]
  - better names for the above

  - Use generic collections ('linear' interface)

* Robustness
  - better error messages (macros/syntax)
  - 'lists' passed to backpropagators might have a tail of (gen-zero) (== null)
    - make sure this case is handled
    - other cases like this?
  - More tests of second derivatives
  - Don't include free-vars in closure variable sensitivities (works, but could blow up quickly)

* Additional backpropagators
 - foldl/foldl0 (definition with define/backprop now works)
 - math/array
 - hash tables (second derivative of)
 - list* without split-at
 - */multiply with more than two args

* Documentation
 - Tips for writing backpropagators (doc page)
   - use scale and add instead of * and +, which will handle structured input and gen-zero
   - might be passed a gen-zero: make sure that this case is handled
     properly, including in e.g. tail position in a list, where it may
     mean null
 - Limitation: keyword arguments won't work




